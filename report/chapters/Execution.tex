\chapter{Execution}
\section{Tools}
\textbf{TODO: } Lilygo t twr beschriibe \\
hends i C gmacht \\
lily go t twr github repo als usgang gno 

\section{Implementation}

First we implemented the modulation of 0's and 1's with two different frequencies, first it was 200 and 400 Hz. To make the transmission better this was changed to 600 and 1200 Hz respectively with a 1 beeing represented by 1200 Hz and a 0 beeing represented by 600 Hz. The modulation was directly implemented in C++ and tested on the Lilygo T-TWR. We teseted it by just reading all the values on the recieving Lilygo T-TWR and analyzing it using a Python script which used fast fourier transformation to get the frequencies. Next we tried to implement this demodulation on the T-TWR itself. Fast fourier transformation was not possible on the T-TWR because it used to much memory and was to slow. We then implemented a simple demodulation that counted how many times a sin wave passed the zero line in a certain time frame. The zero line might change therefor it is constantly updated using a running average. If it passed the zero line more than a certain threshold it was counted as a 1 otherwise as a 0. This worked well and we were able to transmit data from one T-TWR to another. At this point each transmitted bit was transmitted for 250 milliseconds. This meant we had a transmission rate of 4 Baud. This was later improved to about 16 Baud with a transmission time per symbol of 63 milliseconds. After the simple transmission of 0's and 1's worked we started to implement a simple packet format. The first 8 bits contain the length of the message, followd by each character encoded in ASCII. Since each ASCII character is 8 bits long this limits the length of the message to 255 characters. We still needed to detect the start of a message. This was checking if the device is recieving something and transmitting the barker code of length 7 at the beginning of the message to reliably the detect the start of the message. This meant after the barker code we could read the length of the message and then decode exactly as many charcters as the message had. This enabled us to send messages from one T-TWR to another. The T-TWR are connect to a computer using a serial connection over USB. You can type in your message in the terminal and the T-TWR will transmit it to the other T-TWR. The other T-TWR will then send the decoded message to its computer using the serial connection. The next step was to implement forward error correction. We first tried to implement this ourselves but ended up using a library named fecmagic\footnote{https://github.com/Venemo/fecmagic} that was already written in C++. Some adjustemnts to the library were necessary to enable it to run on the T-TWR. Since the library used integers and to an array of booleans we needed to do some type conversion. The library was then used to encode 4 bits at a time using Hamming codes. The encoding doubled the size of each message. The length and the characters of the message were both encoded. After transmission the message is decoded 8 bits at a time. If it was not possible to decode something the device will alert the user using the serial connection. The only thing left now was to tune the speed of the connection. This was done by lowering the length each bit was transmitted for which also meant the threshold for the interpretation needed to be lowered. This was done by trial and error and we ended up with a transmission time of 63 milliseconds for each bit. This meant we have a transmission rate of 16 Baud. Since the forward error correction doubles the size of the message we have a net tranmission rate of 1 byte per second. This is not very fast but we were not able to make it any faster whil still beeing able to decode each character.
